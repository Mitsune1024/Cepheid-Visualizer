<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>How it works â€” Cepheid Visualizer</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="description" content="Technical overview: how Cepheid Visualizer is structured and how its rendering and audio systems work." />
  <style>
    body {
      background: url("assets/bg3.png") no-repeat center center fixed;
      background-size: cover;
      color: #fff;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    .page-overlay {
      background: rgba(0, 0, 0, 0.45);
      min-height: 100vh;
      padding: 28px 16px;
      box-sizing: border-box;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 8px;
    }

    .card {
      background: rgba(0,0,0,0.55);
      border-radius: 10px;
      padding: 18px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      color: #fff;
    }

    header.site-header {
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
      position: sticky;
      top: 0;
      z-index: 40;
    }

    .header-inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 8px;
    }

    .title {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.6px;
    }

    nav.nav a, nav.nav button {
      color: #fff;
      text-decoration: none;
      margin-left: 12px;
      opacity: 0.95;
      font-size: 14px;
      background: transparent;
      border: 0;
      cursor: pointer;
    }

    h1,h2,h3 {
      margin-top: 0;
      color: #fff;
    }

    p, li {
      color: #e7e7e7;
      line-height: 1.55;
    }

    .section {
      margin-bottom: 18px;
    }

    .small {
      color: #ddd;
      font-size: 13px;
    }

    @media (max-width: 860px) {
      .content { padding: 8px; }
    }
  </style>
</head>
<body>
  <div class="page-overlay">
    <header class="site-header">
      <div class="container header-inner">
        <h1 class="title" data-i18n="page_title">How it works</h1>
        <nav class="nav">
          <a class="nav-link" href="index.html" data-i18n="nav_home">Home</a>
          <a class="nav-link" href="about.html" data-i18n="nav_about">About</a>
          <a class="nav-link" href="How.html" data-i18n="nav_how">How it works</a>
          <button id="langToggle" data-i18n="lang_button">ES</button>
        </nav>
      </div>
    </header>

    <main class="container" style="padding-top:18px;">
      <article class="card content">
        <h2 data-i18n="overview_title">Overview</h2>
        <p data-i18n="overview_paragraph">
          Cepheid Visualizer is a Processing-based real-time audio visualizer that composes several modes into a single
          accumulation-based rendering pipeline. The design emphasizes a lightweight architecture that yields glow effects,
          smooth trailing, and audio-reactive motion while remaining straightforward to tune and extend.
        </p>

        <div class="section">
          <h3 data-i18n="rendering_title">Rendering layers</h3>
          <p data-i18n="rendering_paragraph">
            Rendering is organized around three main layers. First, there is the 3D accumulation buffer (a PGraphics in P3D,
            referred to as layerFbo) which stores the last frame's pixels and receives a translucent black rectangle
            each frame to produce the fade effect. Second, a screen-space overlay (overlay2D, P2D) is used to render
            rosettes, stars and other 2D primitives; these are often composited onto layerFbo with additive blending.
            Third, the bloom pass (optional) applies a fullscreen shader to a copy of the accumulation buffer and is drawn additively
            on top of the final composition.
          </p>
        </div>

        <div class="section">
          <h3 data-i18n="audio_title">Audio input and analysis</h3>
          <p data-i18n="audio_paragraph">
            The sketch uses the Processing sound library. Two time-varying measures drive the visuals:
          </p>
          <ul>
            <li data-i18n="audio_item1"><strong>RMS level</strong> from an Amplitude analyzer provides a global loudness value that affects intensity and global scaling.</li>
            <li data-i18n="audio_item2"><strong>FFT bands</strong> from an FFT analyzer populate a spectrum array. A small helper function (fftNorm(index, scale)) samples a band, scales and clamps it to [0,1], allowing modes to read per-band energy easily.</li>
          </ul>
        </div>

        <div class="section">
          <h3 data-i18n="modes_title">Mode structure</h3>
          <p data-i18n="modes_paragraph">
            Each visualization mode is implemented as a dedicated function. Modes either draw straight into layerFbo
            (so they automatically get trails), or they render into overlay2D which is then composited onto the FBO.
            Modes scale their geometry based on the canvas size using min(width,height) so the visuals adapt to different
            resolutions and full-screen sizes.
          </p>
          <p data-i18n="modes_examples">
            Examples of implemented modes:
          </p>
          <ul>
            <li data-i18n="modes_example1"><strong>Shader-sphere</strong>: a fragment shader rendered to overlay2D, taking uniforms (time, resolution, audioLevel) so it reacts to sound and time.</li>
            <li data-i18n="modes_example2"><strong>Grid of cubes</strong>: wireframe cubes arranged in a grid with rotation driven by FFT bands.</li>
            <li data-i18n="modes_example3"><strong>Helix</strong>: a spiral of point-like boxes with a central cube to fill the visual center.</li>
            <li data-i18n="modes_example4"><strong>Ship arms</strong>: an advanced mode that morphs smoothly between multiple parametric formulas using a smoothed morph parameter; audio energy controls the morph intensity.</li>
          </ul>
        </div>

        <div class="section">
          <h3 data-i18n="trails_title">The trails / fade effect</h3>
          <p data-i18n="trails_paragraph">
            Trails are produced by drawing a translucent rectangle over the accumulation buffer every frame. The rectangle's alpha
            is a small number called decayAlpha. A lower decayAlpha means the buffer fades more slowly, so trails last longer.
            If a mode or the code explicitly clears the buffer each frame the trails disappear; the code deliberately avoids that except when switching modes to clear artifacts.
          </p>
        </div>

        <div class="section">
          <h3 data-i18n="shaders_title">Shaders and integration</h3>
          <p data-i18n="shaders_paragraph">
            GLSL shaders (in the sketch data/ folder) are loaded with loadShader() and receive uniforms such as resolution and time. The shader rendering follows the pattern:
          </p>
          <ol>
            <li data-i18n="shaders_step1">set uniforms (time, resolution, audioLevel...)</li>
            <li data-i18n="shaders_step2">activate shader on the target PGraphics</li>
            <li data-i18n="shaders_step3">draw a full-viewport rect to run the fragment shader per pixel</li>
            <li data-i18n="shaders_step4">reset the shader</li>
          </ol>
          <p data-i18n="shaders_note">
            The bloom shader is optional and is applied to a copy of the accumulation buffer before compositing with additive blending.
          </p>
        </div>

        <div class="section">
